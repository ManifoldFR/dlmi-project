################## Median regression ################## ################## ##################
################## ################## ################## ################## ##################
################## ################## ################## ################## ##################
# Guilaume Alfredo, Philomene Chagniot
################## ################## ##################
# Path and Libraries
# Path
# path="C:/Users/philo.PHILOMENE/Documents/ENSAE/stats bayésiennes/"
# # path="C:\\Users\\guill\\Documents\\M2 ENSAE\\Statistiques bayésiennes\\projet"
# Importation des libraries
library(stats)
library(ggplot2)
library('MASS')
# install.packages("pracma")
library('pracma')
# install.packages("invgamma")
library('invgamma')
# install.packages('GeneralizedHyperbolic')
library('GeneralizedHyperbolic')
# install.packages("distr")
library(distr)
# install.packages("truncnorm")
library(truncnorm)
################## ################## ##################
################## ################## ##################
# Data simulation
################## ################## ##################
################## ################## ##################
# 250 values regularly spread
seq_graph=seq(from = -10, to = 10, length.out = 250)
# Parameters definition (same as authors)
mu1=-0.4
mu2=0
mu3=5
sigma1=1
sigma2=1.5
sigma3=2
p1=0.435
p2=0.43
p3=1-p1-p2
# Simulation
simul=(p1*dnorm(seq_graph, mean = mu1, sd = sigma1)+
(p2*dnorm(seq_graph, mean = mu2, sd = sigma2))+
(p3*dnorm(seq_graph, mean = mu3, sd = sigma3)))
# save data
df_simul=data.frame(seq_graph,simul)
# write.csv(df_simul,paste0(path,"df_simul.csv"), row.names = F)
# df_simul=read.csv(paste0(path,"df_simul.csv"), stringsAsFactors = F)
# median
median(df_simul[,"simul"]) #0.02716783
################## ################## ##################
################## ################## ##################
# Semi parametric model
################## ################## ##################
################## ################## ##################
### Parameter generation and full conditional for phi ###
# A priori on phi : Gamma(a,b)
a = 2.5
b = 2.5
phi = rgamma(1,a,b)
### split normal distribution ###
## Construct the distribution object.
## Here, it's a split normal distribution with mode=0, and lower- and
## upper-half standard deviations of theta*phi and phi/theta, respectively.
# construct distribution #
#given a value of theta, phi and a value of epsilon :
dsplitNorm = function(phi, eps, theta) d(UnivarMixingDistribution(Truncate(Norm(0,phi/theta), upper=0),
Truncate(Norm(0,theta*phi), lower=0),
mixCoeff=c(0.5, 0.5)))(eps)
# construct random generation #
#Given a value of phi and a value of theta and a number of sample n :
rsplitNorm = function(phi,theta,n) r(UnivarMixingDistribution(Truncate(Norm(0,phi/theta), upper=0),
Truncate(Norm(0,theta*phi), lower=0),
mixCoeff=c(0.5, 0.5)))(n)
# Test the random generation
#x = rsplitNorm(phi, theta + 2,1e6)
#hist(x, breaks=100, col="grey")
####### generalized inverse gaussian distribution #######
#Test (random generation)
#param = c(2, 3, 1)
#rgig(1, param = param)
###### toy example #####
n = 10
k = 3
x = matrix(runif(n*k),n,k)
y = runif(n)
################# Simulated data
# df_simul=read.csv("C:/Users/philo.PHILOMENE/Documents/ENSAE/stats bayésiennes/df_simul.csv",stringsAsFactors = F)
x=df_simul[,"seq_graph"]
# x=vector(x)
y=df_simul[,"simul"]
n=length(x)
k=1
dim(x) <- c(length(x), k)
# ################## Real censored data
# library(survival)
# data=retinopathy
# data
# # Number of treated and non treated
# sum(data$trt==0)
# sum(data$trt==1)
#######################################################################
### theta initialization from dirichlet process with base measure G0 ##
#######################################################################
# r = 1
# r=10
r=mean(y)
r
s = 2
t = ((r/6)**2)*(s-1)
#################################
###                           ###
### Sethuraman representation ###
###                           ###
#################################
c <- 1 # c is the precision parameter
G_0 <- function(n) rinvgamma(n, s, t) # G_0 is the base distribution
b_ <- rbeta(n, 1, c)
p <- numeric(n)
p[1] <- b_[1]
p[2:n] <- sapply(2:n, function(i) b_[i] * prod(1 - b_[1:(i-1)]))
y <- G_0(n)
theta <- sample(y, prob = p, replace = TRUE)
theta
########################################
####### apha and beta generation #######
########################################
var = rep(100,k+1)
Sigma = diag(var,k+1,k+1)
mu = rep(0,k+1)
coeff = mvrnorm(n = 1, mu, Sigma, tol = 1e-6, empirical = FALSE, EISPACK = FALSE)
alpha = coeff[1]
beta = coeff[2:(k+1)]
############################
### full phi conditional ###
############################
update_phi = function(y,x,alpha,beta,n=n,a=a,b=b){
if (length(beta)==1){
z=y - alpha*rep(1,n) - (beta*x)
}
else{
z = c(y - alpha*rep(1,n) - dot(beta,t(x)))}
pos_idx = which(z >= 0)
neg_idx = which(z < 0)
z_plus = z[pos_idx]
z_minus = z[neg_idx]
theta_plus = theta[pos_idx]
theta_minus = theta[neg_idx]
n1 = length(theta_plus)
n2 = length(theta_minus)
lambda = (n1 - n2 + 2*a)/2
psi = 2*b + sum((z_plus**2)/theta_plus)
print(psi)
chi = sum((z_minus**2)/theta_minus)
print(length(psi))
print(lambda)
# Conditional distribution of phi
param = c(chi, psi, lambda)
return(rgig(1, param = param)) #random generation
}
phi=update_phi(y,x,alpha,beta,n,a,b)
phi
###############################
###### theta i posterior ######
###############################
if(k==1){
eps = c(y - alpha*rep(1,n) - (beta*x))
}else {
eps = c(y - alpha*rep(1,n) - dot(beta,t(x)))}
# # simulated data
A = function(eps,i,phi) {
(phi**(0.5) * ((2*t)**s) * gamma(s + 0.5))/(pi**(0.5) * gamma(s) * (2*t + phi*(eps[i])**2)**(s+ 0.5))*(eps[i] >= 0)
+ ((2*phi*t)**s * gamma(s + 0.5))/(pi**(0.5) * gamma(s) * (2*phi*t + eps[i]**2)**(s + 0.5))*(eps[i] < 0)
}
# parameter of the inverse gamma distribution
t_tilda = function(phi,eps,t,i){
(0.5)*(2*t + phi*(eps[i]**2))*(eps[i]>=0) + (1/(2*phi))*(2*phi*t + eps[i]**2)*(eps[i] < 0)
}
#Function used to generate all p(eps_i,theta_j)
# df_simul=read.csv(paste0(path,"df_simul.csv"), stringsAsFactors = F)
eps=df_simul[,"seq_graph"]
theta_par_init=rinvgamma(n, s, t)
update_theta=function(n,s,t,eps,phi,theta_par_init){
#initialize theta :
theta_par = theta_par_init
# parameter for the inverse gamma distribution
s_tilda = s + 0.5
# get all values of A_i and t_tilda_i
A_tot=sapply(1:n,function(x){A(eps,x,phi)})
t_tilda_tot=sapply(1:n,function(x){t_tilda(phi,eps,t,x)})
i=1
while(i<=n){
print("inner loop")
print(i)
p_eps_th = c(lapply(theta_par, function(thet_val){dsplitNorm(phi,eps[i],thet_val)}))
#proba for a specific theta_par_i
p_eps_th_i = p_eps_th[i]
# proba for all other theta_par_j's except theta_par i
p_eps_th_minusi = unlist(p_eps_th[-i], use.names = FALSE)
sum_p_eps_th_minusi = sum(p_eps_th_minusi)
# calculate masses
# discrete mass
discrete_mass = sapply(p_eps_th_minusi,
function(x) {(1/((A_tot[i] + sum_p_eps_th_minusi))) * x})
# continuous mass
continuous_mass = (1/((A_tot[i] + sum_p_eps_th_minusi ))) * A_tot[i]
theta_sampled=sample(1:n, size=1, prob = c(unlist(discrete_mass),continuous_mass))
print(theta_sampled)
#update theta_par_i
if (theta_sampled==n){
theta_par[i]=rinvgamma(1, s_tilda, t_tilda_tot[i])
}
else{
if(theta_sampled<i){
theta_par[i]=theta_par[theta_sampled]
}
if(theta_sampled>=i){
theta_par[i]=theta_par[(theta_sampled+1)]
}}
if(!is.na(theta_par[i])){
i=i+1
}
}
return(theta_par)
}
new_theta=update_theta(n,s,t,eps,phi,theta_par_init)
############### draw
theta_prior=rinvgamma(n, s, t)
draw_theta_prior=sapply(1:n,function(x){dsplitNorm(phi,eps[x],theta_prior[x])})
draw_new_theta=sapply(1:n,function(x){dsplitNorm(phi,eps[x],new_theta[x])})
df_draw_new_theta=data.frame("seq_graph"=eps,"simul_method"=draw_new_theta)
df_draw_new_theta[,"theta_prior"]=draw_theta_prior
write.csv(df_draw_new_theta,paste0(path,"output/seq/df_draw_new_theta.csv"),row.names = F)
p=ggplot(df_draw_new_theta,aes(seq_graph,simul_method)) + geom_line()+ geom_line(aes(seq_graph,theta_prior),color="orange") +
xlab("Valeurs") + ylab("Densité")
p
p_lim=ggplot(df_draw_new_theta,aes(seq_graph,simul_method)) +  geom_line() +
xlab("Valeurs") + ylab("Densité")  +  ylim(0, 0.3)
p_lim
## Comparison with data simulated
df_simul=df
df_simul=cbind(df_simul,draw_new_theta,draw_theta_prior)
# write.csv(df_simul,paste0(path,"output/seq/df_simul_with_seq_values_on_top.csv"),row.names = F)
names(df_simul)
df_simul["simul_method"]=sapply(1:n,function(x){dsplitNorm(phi,df_simul[x,"seq_graph"],new_theta[x])})
p2=ggplot(df_simul) +  geom_line(aes(seq_graph,simul)) +geom_line(aes(seq_graph,draw_new_theta),color='blue')+
geom_line(aes(seq_graph,draw_theta_prior),color='orange')+ xlab("Valeurs") + ylab("Densité")  +  ylim(0, 0.3)
p2
p3=ggplot(df_simul) +  geom_line(aes(seq_graph,simul)) +
xlab("Valeurs") + ylab("Densité")
p3
p4=ggplot(df_simul) +  geom_line(aes(seq_graph,simul)) +
xlab("Valeurs") + ylab("Densité")  +  ylim(0, 0.3)
p4
p5=ggplot(df_simul) +  geom_line(aes(seq_graph,simul)) +
xlab("Valeurs") + ylab("Densité")  +  ylim(0, 0.3)
p5
################## Create a chain
# MC=30
MC=2
mc_index=1
list_phi=NULL
list_theta_prior=NULL
list_new_theta=NULL
while (mc_index<=MC){
print(mc_index)
phi=update_phi(y,x,alpha,beta,n,a,b)
list_phi=c(list_phi,phi)
print(phi)
theta_par_init=rinvgamma(n, s, t)
list_theta_prior=c(list_theta_prior,theta_par_init)
new_theta=update_theta(n,s,t,eps,phi,theta_par_init)
print(new_theta)
list_new_theta=c(list_new_theta,new_theta)
mc_index=1+mc_index
# save.image(paste0("~/ENSAE/stats bayésiennes/save_mc_",mc_index,".RData"))
}
new_theta
################ Last draw
index=mc_index
theta_last=list_new_theta[(250*(index-2)+1):(250*(index-1))]
theta_prior_last=list_theta_prior[(250*(index-2)+1):(250*(index-1))]
phi_last=list_phi[index-1]
draw_theta_last=sapply(1:n,function(x){dsplitNorm(phi_last,eps[x],theta_last[x])})
draw_theta_prior_last=sapply(1:n,function(x){dsplitNorm(phi_last,eps[x],theta_prior_last[x])})
df_last=df_simul
df_last["simul_last"]=draw_theta_last
df_last["prior_last"]=draw_theta_prior_last
p=ggplot(df_last,aes(seq_graph,simul)) + geom_line(size=0.8,color="orchid")+ geom_line(aes(seq_graph,prior_last),color="orange") +
geom_line(aes(seq_graph,simul_last),color="blue")  + xlab("Valeurs") + ylab("Densité")
p
p_lim=ggplot(df_last,aes(seq_graph,simul)) + geom_line(size=0.8,color='orchid')+ geom_line(aes(seq_graph,prior_last),color="orange") +
geom_line(aes(seq_graph,simul_last),color="blue")  + xlab("Valeurs") + ylab("Densité") +ylim(0,0.3)
p_lim
dd=setNames(df_last[,c("seq_graph","simul_last")],c("seq_graph","simul"))
head(dd)
df_test=rbind(dd,df_last[,c("seq_graph","simul")])
p_test=ggplot(df_test,aes(seq_graph,simul)) + geom_line() + xlab("Valeurs") + ylab("Densité")+ylim(0,0.3)
p_test
ggplot(df,aes(seq_graph,simul)) + geom_line() + xlab("Valeurs") + ylab("Densité")+ylim(0,0.3)
df_last["diff_prior"]=abs(df_last[,"simul"]-df_last[,"prior_last"])
df_last["diff_last"]=abs(df_last[,"simul"]-df_last[,"simul_last"])
p_diff=ggplot(df_last) + geom_line(aes(seq_graph,diff_prior),color="orange") +
geom_line(aes(seq_graph,diff_last),color="blue")  + xlab("Valeurs") + ylab("Valeur absolue de la différence des densités")
p_diff
p_diff_lim=ggplot(df_last) + geom_line(aes(seq_graph,diff_prior),color="orange") +
geom_line(aes(seq_graph,diff_last),color="blue")  + xlab("Valeurs") + ylab("Valeur absolue de la différence des densités")+ylim(0,0.15)
p_diff_lim
# diff first last
df_tot=df_last
df_it1_it15=setNames(df_tot[,c("seq_graph","diff_last")],c("seq_graph","diff_first"))
df_it1_it15["diff_last"]=df_last[,"diff_last"]
p_diff_fl=ggplot(df_it1_it15) + geom_line(aes(seq_graph,diff_first),color="skyblue",size=1) +
geom_line(aes(seq_graph,diff_last),color="blue",size=1)  + xlab("Valeurs") + ylab("Valeur absolue de la différence des densités")
p_diff_fl
p_diff_fl_lim=ggplot(df_it1_it15) + geom_line(aes(seq_graph,diff_first),color="skyblue",size=1) +
geom_line(aes(seq_graph,diff_last),color="blue",size=1)  + xlab("Valeurs") + ylab("Valeur absolue de la différence des densités")+ylim(0,0.15)
p_diff_fl_lim
########################
### Beta j posterior ###
########################
# numerator of the (u_ij) matrix
u_ij_num=sapply(1:n,function(j){(x[,-j] %*% beta[-j])})
#initialization
u_ij_mat=x*0
u_ij_mat_sorted=x*0 # matrix with the sorted values
u_ij_mat_argsorted=x*0 # indices wrt to the initial (non sorted) matrix
for (j in 1:k){
print(j)
print(length(((y-alpha-u_ij_num[j])*((1/x)[,j]))))
u_ij_mat[,j]=((y-alpha-u_ij_num[j])*((1/x)[,j]))
sort=sort(u_ij_mat[,j], index.return=TRUE)
u_ij_mat_sorted[,j]=sort$x #sorted values
u_ij_mat_argsorted[,j]=sort$ix  #"argsort"
}
# /! mu and sigma of size k+1
mu # k+1
Sigma #k+1 x k+1 /! define sigma as standard deviation AND NOT VARIANCE -- take the square
# Used for the numerator
sum_x_sq_u_index=function(index_init,index_end,j){
seq=sapply(index_init:index_end,function(i){(x[i,j]^2)*(u_ij_mat_sorted[i,j])/theta[i]})
sum=sum(seq)
return(sum)
}
# used for the denominator
sum_x_sq_index=function(index_init,index_end,j){
seq=sapply(index_init:index_end,function(i){(x[i,j]^2)/theta[i]})
sum=sum(seq)
return(sum)
}
#used for r_kj
sum_x_sq_u_sq_index=function(index_init,index_end,j){
seq=sapply(index_init:index_end,function(i){(x[i,j]^2)*(u_ij_mat_sorted[i,j]^2)/theta[i]})
sum=sum(seq)
return(sum)
}
mu_tilda_kj=function(k,j){ #k between 0 and n
if(k==0){ # be careful of sum index
num = phi*mu[j+1] + (phi**2)*(Sigma[j+1,j+1]**2)*sum_x_sq_u_index(1,n,j)
denom = phi + sum_x_sq_index(k+1,n,j)*(phi**2)*(Sigma[j+1,j+1]**2)
return (num/denom)
}
if(k==(n)){ # be careful of sum index
num = (phi*mu[j+1]) + ((Sigma[j+1,j+1])**2)*sum_x_sq_u_index(1,k,j)
denom = phi + (Sigma[j+1,j+1]**2)*sum_x_sq_index(1,k,j)
return (num/denom)
}
else{
num=(phi*mu[j+1])+((Sigma[(j+1),(j+1)]^2)*sum_x_sq_u_index(1,k,j))+
(((phi*Sigma[(j+1),(j+1)])^2)*sum_x_sq_u_index((k+1),n,j))
denom=phi+((Sigma[(j+1),(j+1)]^2)*sum_x_sq_index(1,k,j))+
(((phi*Sigma[(j+1),(j+1)])^2)*sum_x_sq_index((k+1),n,j))
return (num/denom)}
}
Sigma_sq_tilda_kj=function(k,j){ #k between 0 and n
num=phi*(Sigma[(j+1),(j+1)]^2)
if(k==0){ # be careful of sum index
denom=phi+ (phi**2)*(Sigma[(j+1),(j+1)]^2)*sum_x_sq_index((k+1),n,j)
return(num/denom)
}
if(k==n){ # be careful of sum index
denom=phi+((Sigma[(j+1),(j+1)]^2)*sum_x_sq_index(1,k,j))
return(num/denom)
}
else{
denom=phi+((Sigma[(j+1),(j+1)]^2)*sum_x_sq_index(1,k,j))+
(((phi*Sigma[(j+1),(j+1)])^2)*sum_x_sq_index((k+1),n,j))
return(num/denom)}
}
#constants
r_kj=function(k,j){
denom=2*phi*(Sigma[(j+1),(j+1)]^2)
if(k==0){ #??
num = (phi*(mu[j+1])**2) + (phi**2)*(Sigma[j+1,j+1]**2)*sum_x_sq_u_sq_index(k+1,n,j)
return (num/denom)
} else if (k==n){
num = (phi*(mu[j+1])**2) + (Sigma[j+1,j+1]**2)*sum_x_sq_u_sq_index(1,k,j)
return (num/denom)
}
else{
num=(phi*(mu[j+1]**2))+((Sigma[(j+1),(j+1)]^2)*sum_x_sq_u_sq_index(1,k,j))+
(((phi*Sigma[(j+1),(j+1)])^2)*sum_x_sq_u_sq_index((k+1),n,j))}
return(num/denom)
}
v_kj=function(k,j){
v=(phi^(-k))*(Sigma_sq_tilda_kj(k,j)^0.5)*exp(-r_kj(k,j)+(0.5*(mu_tilda_kj(k,j)^2)/Sigma_sq_tilda_kj(k,j)))
return(v)
}
# Interval -- return the lower and upper bound
T_kj=function(k,j){
if(k==0){
Tkj_lower_bound=-Inf
Tkj_upper_bound= u_ij_mat_sorted[1,j]
}
if (k==n){
Tkj_lower_bound=u_ij_mat_sorted[n,j]
Tkj_upper_bound=Inf
}
else{
Tkj_lower_bound=u_ij_mat_sorted[k,j]
Tkj_upper_bound=u_ij_mat_sorted[(k+1),j]
}
return(c(Tkj_lower_bound,Tkj_upper_bound))
}
# write the integral as the difference between the cdf evaluated in the two values of interest
c_kj=function(k,j){ #k between 0 and n
if (k==0){
Tkj_lower_bound = -Inf
Tkj_upper_bound=T_kj(k,j)[1]
} else if (k==n){
Tkj_lower_bound=T_kj(k,j)[1]
Tkj_upper_bound= Inf
}else{
Tkj_lower_bound=T_kj(k,j)[1]
Tkj_upper_bound=T_kj(k,j)[2]
}
mu=mu_tilda_kj(k,j)
sig= (Sigma_sq_tilda_kj(k,j))^0.5 #or variance ? pnorm takes the sd as input.. ????
integral=pnorm(Tkj_upper_bound, mu, sig) - pnorm(Tkj_lower_bound, mu, sig)
return(integral)
}
for (i in 0:n){
print(c_kj(i,1))
}
#weights
w_kj=function(k,j){
num=v_kj(k,j)*c_kj(k,j)
denom=sum(sapply(0:n,function(l){v_kj(l,j)*c_kj(l,j)}))
return(num/denom)
}
w_kj(1,1) # problème : division par zéro car tous les coeff v sont nuls (terme dans l'exponentielle très petit)
sapply(0:n, function(k) w_kj(k,j))
install.packages(stapler)
install.packages("stapler")
getwd()
setwd("C:\\Users\\Philo\\Documents\\3A -- MVA\\DL for medical imaging\\retine\\dlmi-project\\")
getwd()
path='data\stare'
path='data\\stare'
load.image(paste0(c(path,"annotation 1","im0001.ah.png")))
install.packages("OpenImageR")
im_file1=c(path,"annotation 1","im0001.ah.png")
im_file1
paste0(c(path,"annotation 1","im0001.ah.png"))
paste0(c(path,"annotation 1","im0001.ah.png"))
paste0(path,"annotation 1","im0001.ah.png")
im_file1=paste0(path,"annotation 1","\\im0001.ah.png")
im_file2=paste0(path,"annotation 2","\\im0001.vk.png")
im=load.image(im_file1)
im=load.image()
im=readImage(im_file1)
im=readImage(im_file1)
library(OpenImageR)
im=readImage(im_file1)
im_file1
im_file1=paste0(path,"\\annotation 1","\\im0001.ah.png")
im_file2=paste0(path,"\\annotation 2","\\im0001.vk.png")
im=readImage(im_file1)
im
unique(im)
unique(dataframe(im))
class(im)
que(as.vector(im))
unique(as.vector(im))
im2=readImage(im_file2)
im1=readImage(im_file1)
im2=readImage(im_file2)
sum(im1-im2)
sum(abs(im1-im2))
cbind(im1,im2)
dim(im)
im=cbind(im1,im2)
dim(im)
dim(im1)[1]
im=array(0,dim=c(dim(im1)[1],dim(im1)[2],2))
dim(im)
dim(im[1:10,1:10,])
dim(im)
im[1:dim(im)[1],1:dim(im)[2],1]=im1
im[1:dim(im)[1],1:dim(im)[2],2]=im2
matrix(im)
dim(matrix(im))
dim(im)
unique(im)
unique(as.vector(im))
stapler(im)
library(stapler)
stapler(im)
library(stapler)
staple(im)
staple(c(im1,im2))
staple(list(c(im1,im2)))
